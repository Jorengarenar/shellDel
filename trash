#!/bin/bash

# bashtrash - a bash script implementation of the FreeDesktop.org Trash
# Specification.

# Copyright (c) 2009-2011, Robert Rothenberg <robrwo@gmail.com>

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

version="0.3.8 \$Id: trash 2011/06/18 13:04:58 BST rr@newfie $"

progname=`basename $0`

function show_usage {
  cat << EOU
Usage: ${progname} [OPTION]... FILE...

Move files into the trash.

Options:
  --version		show program's version number and exit
  -h, --help		show this help message and exit
  -v, --verbose		explain what is being done
  -i, --interactive	prompt before moving every file
  -r, -R, --recursive   ignored (for compatability with rm)
  -f, --force		ignore non-existent files, never prompt
EOU
}

function try_help {
  echo "Try \`${progname} --help' for more information." 1>&2
  exit 1
}

# Option handling

if ! options=$(getopt -o hvirRf -l "help,verbose,interactive::,version,recursive,force" -n "${progname}" -- "$@")
then
  exit 1
fi

if [ $# -eq 0 ]; then
  try_help
fi

#set -- "$options"

verbose=0
interactive=never

function strip_quotes {
  x="$1"
  x="${x#\'}"
  x="${x%\'}"
  echo "${x}"
}

while [ $# -gt 0 ]
do
case $1 in
    -h|--help) show_usage ; exit 1;;
    -v|--verbose) verbose=1 ;;
    -i) interactive=always ;;
    --interactive) shift ;
      arg=`strip_quotes "$1"`
      if [ -z "$arg" ]; then
        arg=always
      fi
      interactive=$arg
      ;;
    --version) echo "${progname} $version" 1>&2 ;;
    -r|-R|--recursive) ;;
    -f|--force) interactive=force ;;
    (--) shift; break;;
    (-*) echo "${progname}: invalid option -- '$1'" 1>&2 ; try_help ; exit 1 ;;
    (*) break;;
    esac
  shift
done

# sed script to encode filenames

sedscript='s/ /%20/g
s/!/%21/g
s/"/%22/g
s/\#/%23/g
s/\$/%24/g
s/\&/%26/g
s/'\''/%27/g
s/(/%28/g
s/)/%29/g
s/\*/%2a/g
s/+/%2b/g
s/,/%2c/g
s/-/%2d/g
s/:/%3a/g
s/;/%3b/g
s//%3e/g
s/?/%3f/g
s/@/%40/g
s/\[/%5b/g
s/\\/%5c/g
s/\]/%5d/g
s/\^/%5e/g
s/_/%5f/g
s/`/%60/g
s/{/%7b/g
s/|/%7c/g
s/}/%7d/g
s/~/%7e/g
s/	/%09/g'

function url_encode {
  echo $1 |sed -e "$sedscript"
}

function get_trashdir {
  mounts=`awk '{ print $2 }' /proc/mounts`
  base=/

  if [ "$EUID" != "0" ]; then
    mounts="$HOME $mounts"
  fi

  for i in $mounts
  do
    if [[ $1 =~ ^$i ]]
    then
      if [[ $i =~ ^$base ]]
      then
        base=$i
      fi
    fi
  done

  if [ "$base" != "$HOME" ]; then
    trashdir="$base/.Trash/$UID"
    if [ ! -d "$trashdir" ]; then
      trashdir="$base/.Trash-$UID"
    fi

    mkdir -p "$trashdir"
    if [ "$?" != "0" ]; then
      base=$HOME
    fi
  fi

  if [ "$base" == "$HOME" ]; then
    base=$XDG_DATA_HOME
    if [ -z "$base" ]; then
      base="$HOME/.local/share/"
    fi
    trashdir="$base/Trash"
  fi

  echo $trashdir
}

# configure options

mv_opts=""

if [ $verbose != 0 ]; then
  mv_opts="${mv_opts} -v"
fi

function can_trash {
  filename="$1"

  if [ ! -e "$filename" ]; then
    if [ "$interactive" != "force" ]; then
      echo "${progname}: cannot move \`$filename' to trash: No such file or directory" 1>&2
    fi
    echo 0
  else

    type="file"
    if [ -d "$filename" ]; then
      type="directory"
    fi

    case $interactive in
      never|force) echo 1 ;;
      always)
        read -p "${progname}: move ${type} '${filename}' to trash?" yn
        if [[ "$yn" =~ ^[yY]$ ]]; then
          echo 1
        else
          echo 0
        fi
        ;;
      *) echo "${progname}: unsupported value interactive=${interactive}" 1>&2 ; echo 0; exit 1 ;;
    esac
  fi
}

function init_trashdir {
  trashdir=$1

  mkdir -p "$trashdir/files"
  if [ "$?" != "0" ]; then
    echo "${progname}: unable to write to $trashdir" 1>&2
    exit 2
  fi

  mkdir -p "$trashdir/info"
  if [ "$?" != "0" ]; then
    echo "${progname}: unable to write to $trashdir" 1>&2
    exit 2
  fi
}

function trash_file {
  filename=$1

  dir=${filename%/*}

  trashdir=`get_trashdir "$dir"`
  init_trashdir "$trashdir"

  trashname="${filename##*/}"
  origname="${trashname%%.*}"
  ext=".${trashname##*.}"
  if [ "$ext" == ".$trashname" ]; then
    ext=""
  fi

  cnt=1
  while [ -e "$trashdir/files/$trashname" ] || \
        [ -e "$trashdir/info/$trashname.trashinfo" ]; do
    trashname="${origname}_${cnt}${ext}"
    let cnt=cnt+1
  done

  deletedfile="$trashdir/files/$trashname"
  deletedinfo="$trashdir/info/$trashname.trashinfo"

  canon=`url_encode "$filename"`

  cat > "$deletedinfo" <<END
[Trash Info]
Path=$canon
DeletionDate=`date +"%FT%H:%M:%S"`
END

  mv $mv_opts "$filename" "$deletedfile"
}

for f in "$@"
do
  # strip quotes added by getopts

  f=`strip_quotes "${f}"`

  # get full pathname of file

  filename="$(readlink -f "${f}")"

  yes=`can_trash "$filename"`
  if [ "$yes" != "0" ]; then
    trash_file "$filename"
  fi

done

exit 0





